[{"/home/gabriel/Documents/ipca/frontend/app/src/index.tsx":"1","/home/gabriel/Documents/ipca/frontend/app/src/serviceWorker.ts":"2","/home/gabriel/Documents/ipca/frontend/app/src/app/store.ts":"3","/home/gabriel/Documents/ipca/frontend/app/src/App.tsx":"4","/home/gabriel/Documents/ipca/frontend/app/src/slices/dataSlice.ts":"5","/home/gabriel/Documents/ipca/frontend/app/src/components/DefaultAppBar.tsx":"6","/home/gabriel/Documents/ipca/frontend/app/src/components/ScalingSliders.tsx":"7","/home/gabriel/Documents/ipca/frontend/app/src/components/charts/ParallelCoordinatesChart.tsx":"8","/home/gabriel/Documents/ipca/frontend/app/src/wrappers/Dimensions.tsx":"9","/home/gabriel/Documents/ipca/frontend/app/src/components/charts/common.ts":"10","/home/gabriel/Documents/ipca/frontend/app/src/components/charts/ScatterPlotMatrixChart.tsx":"11","/home/gabriel/Documents/ipca/frontend/app/src/components/charts/ScatterChart.tsx":"12","/home/gabriel/Documents/ipca/frontend/app/src/api/dataClient.ts":"13","/home/gabriel/Documents/ipca/frontend/app/src/api/common.ts":"14","/home/gabriel/Documents/ipca/frontend/app/src/api/modelClient.ts":"15","/home/gabriel/Documents/ipca/frontend/app/src/components/DatasetPicker.tsx":"16"},{"size":663,"mtime":1609633973680,"results":"17","hashOfConfig":"18"},{"size":6248,"mtime":1609633973640,"results":"19","hashOfConfig":"18"},{"size":853,"mtime":1609633973624,"results":"20","hashOfConfig":"18"},{"size":2545,"mtime":1609713488091,"results":"21","hashOfConfig":"18"},{"size":5230,"mtime":1609712560677,"results":"22","hashOfConfig":"18"},{"size":772,"mtime":1609372355615,"results":"23","hashOfConfig":"18"},{"size":2089,"mtime":1609713537829,"results":"24","hashOfConfig":"18"},{"size":4194,"mtime":1609698984672,"results":"25","hashOfConfig":"18"},{"size":2001,"mtime":1609698886226,"results":"26","hashOfConfig":"18"},{"size":843,"mtime":1609710026645,"results":"27","hashOfConfig":"18"},{"size":5079,"mtime":1609698387467,"results":"28","hashOfConfig":"18"},{"size":10527,"mtime":1609712060348,"results":"29","hashOfConfig":"18"},{"size":519,"mtime":1609633973684,"results":"30","hashOfConfig":"18"},{"size":360,"mtime":1609711765601,"results":"31","hashOfConfig":"18"},{"size":251,"mtime":1609633973664,"results":"32","hashOfConfig":"18"},{"size":1438,"mtime":1609712012151,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"7a2mzw",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"36"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"36"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"/home/gabriel/Documents/ipca/frontend/app/src/index.tsx",[],["69","70"],"/home/gabriel/Documents/ipca/frontend/app/src/serviceWorker.ts",[],"/home/gabriel/Documents/ipca/frontend/app/src/app/store.ts",[],"/home/gabriel/Documents/ipca/frontend/app/src/App.tsx",["71"],"/home/gabriel/Documents/ipca/frontend/app/src/slices/dataSlice.ts",[],"/home/gabriel/Documents/ipca/frontend/app/src/components/DefaultAppBar.tsx",[],"/home/gabriel/Documents/ipca/frontend/app/src/components/ScalingSliders.tsx",[],"/home/gabriel/Documents/ipca/frontend/app/src/components/charts/ParallelCoordinatesChart.tsx",[],"/home/gabriel/Documents/ipca/frontend/app/src/wrappers/Dimensions.tsx",[],"/home/gabriel/Documents/ipca/frontend/app/src/components/charts/common.ts",[],"/home/gabriel/Documents/ipca/frontend/app/src/components/charts/ScatterPlotMatrixChart.tsx",["72","73","74","75","76"],"import React, {useEffect, useRef} from \"react\";\nimport {AppDispatch, RootState, useTypedSelector} from \"../../app/store\";\nimport {projectData, selectAllScaledData, selectDataScaling, updateScaling} from \"../../slices/dataSlice\";\nimport {Dimensions, withDimensions} from \"../../wrappers/Dimensions\";\nimport * as d3 from \"d3\";\nimport {Data} from \"../../types/data\";\nimport {COLORS, getFixedDomainExtents} from \"./common\";\nimport {GroupSelection} from \"../../types/d3\";\nimport {connect} from \"react-redux\";\n\ntype RootSelection = d3.Selection<SVGSVGElement, unknown, null, undefined>;\n\ninterface Size {\n    readonly w: number\n    readonly h: number\n}\n\ninterface SPLOMScales {\n    readonly xScales: d3.ScaleLinear<number, number>[];\n    readonly yScales: d3.ScaleLinear<number, number>[];\n}\n\nconst BUFFER_PROPORTION = 1 / 20;\n\n\nconst createGroups = (rootG: RootSelection) => {\n    rootG.append(\"g\").attr(\"id\", \"yAxisG\");\n    rootG.append(\"g\").attr(\"id\", \"xAxisG\");\n    rootG.append(\"g\").attr(\"id\", \"cellG\");\n}\n\nconst getMargins = ({width, height}: Dimensions) => {\n    return {w: width * (1 / 40), h: height * (1 / 40)};\n}\n\nconst getPlotSizes = ({width, height}: Dimensions, margins: Size, numFeatures: number) => {\n    const w = (width - (numFeatures + 1) * margins.w) / numFeatures\n    const h = (height - (numFeatures + 1) * margins.h) / numFeatures\n\n    return {w, h}\n}\n\nconst getRangeExtents = (data: Data, domainExtents: number[][]) => {\n    return domainExtents.map(extrema => {\n        const range = extrema[1] - extrema[0];\n        return [extrema[0] - (range * BUFFER_PROPORTION), extrema[1] + (range * BUFFER_PROPORTION)]\n    });\n}\n\nconst joinPlotGroups = (rootG: RootSelection, plotCrossProducts: number[][], plotSizes: Size, margins: Size) => {\n    return rootG.select('#cellG')\n        .selectAll(\"g\")\n        .data(plotCrossProducts)\n        .join(\"g\")\n        .attr(\"transform\", ([i, j]) => {\n            return `translate(${(i * (plotSizes.w + margins.w)) + margins.w},${(j * (plotSizes.h + margins.h)) + margins.h})`\n        });\n}\n\nconst getScales = (numFeatures: number, extents: number[][], plotSizes: Size) => {\n    const x = d3.range(numFeatures).map(c => d3.scaleLinear()\n        .domain(extents[c])\n        .range([0, plotSizes.w]));\n\n    const y = x.map((x, i) => x.copy().range([plotSizes.h, 0]));\n    return {xScales: x, yScales: y}\n}\n\nconst joinRects = (cell: GroupSelection, plotCrossProducts: number[][], plotSizes: Size) => {\n    cell.each(function ([i, j]) {\n        d3.select(this)\n            .selectAll(\"rect\")\n            .data(plotCrossProducts)\n            .join(\"rect\")\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke-width\", 1.5)\n            .attr(\"stroke\", \"#aaa\")\n            .attr(\"width\", plotSizes.w)\n            .attr(\"height\", plotSizes.h);\n    });\n}\n\nconst joinCircles = (cell: GroupSelection, data: Data, scales: SPLOMScales) => {\n    cell.each(function ([i, j]) {\n        d3.select(this)\n            .selectAll(\"circle\")\n            .data(data)\n            .join(\"circle\")\n            .attr(\"cx\", d => scales.xScales[i](d.features[i]))\n            .attr(\"cy\", d => scales.yScales[j](d.features[j]))\n            .attr(\"r\", 1.5)\n            .attr(\"fill\", d => COLORS(d.target))\n            .attr(\"fill-opacity\", 0.7);\n    });\n}\n\n\ninterface ScatterPlotMatrixChartProps {\n    readonly dimensions: Dimensions;\n    readonly data: Data;\n}\n\nconst ScatterPlotMatrixChart: React.FC<ScatterPlotMatrixChartProps> = (props) => {\n    const d3Container = useRef<SVGSVGElement>(null);\n    // const data = useTypedSelector((state) => selectAllScaledData(state));\n    const data = props.data;\n    const dimensions = props.dimensions;\n\n    useEffect(() => {\n        if (d3Container.current !== null) {\n            const rootG = d3.select(d3Container.current);\n            createGroups(rootG);\n        }\n    }, []);\n\n\n    useEffect(() => {\n        if (data.length > 0 && d3Container.current !== null) {\n            const numFeatures = data[0].features.length;\n            const margins = getMargins(dimensions);\n            const plotSizes = getPlotSizes(dimensions, margins, numFeatures);\n            const domainExtents = getFixedDomainExtents(numFeatures);\n            const extents = getRangeExtents(data, domainExtents)\n            const plotCrossProducts = d3.cross(d3.range(numFeatures), d3.range(numFeatures));\n            const rootG = d3.select(d3Container.current);\n            const cell = joinPlotGroups(rootG, plotCrossProducts, plotSizes, margins);\n            const scales: SPLOMScales = getScales(numFeatures, extents, plotSizes);\n            joinRects(cell, plotCrossProducts, plotSizes);\n            joinCircles(cell, data, scales);\n\n        }\n    }, [data, dimensions]);\n\n    return (<svg ref={d3Container} width={dimensions.width} height={dimensions.height}/>)\n}\n\n\nconst ResponsiveScatterPlotMatrixChart = withDimensions(ScatterPlotMatrixChart);\n\nconst mapStateToProps = (state: RootState) => ({\n    data: selectAllScaledData(state),\n});\n\nexport default connect(\n    mapStateToProps,\n)(ResponsiveScatterPlotMatrixChart);\n","/home/gabriel/Documents/ipca/frontend/app/src/components/charts/ScatterChart.tsx",["77","78","79","80"],"import React, {useEffect, useRef} from \"react\";\n\nimport * as d3 from 'd3';\nimport {Data, DataInstance, ProjectedData, ProjectedDataInstance} from \"../../types/data\";\nimport {Dimensions, withDimensions} from \"../../wrappers/Dimensions\";\nimport {RootState, useTypedSelector} from \"../../app/store\";\nimport {selectAllData, selectAllScaledData} from \"../../slices/dataSlice\";\nimport {COLORS, isProjected} from \"./common\";\nimport {connect} from \"react-redux\";\n\n// The version of d3 types is like two major versions behind the actual d3\n// version, so for the most part ignore typescript\n\n\ntype RootSelection = d3.Selection<SVGSVGElement, unknown, null, undefined>;\n\ntype Scale = d3.ScaleLinear<number, number>;\n\ninterface Scales {\n    readonly xScale: Scale;\n    readonly yScale: Scale;\n}\n\ninterface D3Coords {\n    readonly startX: number;\n    readonly endX: number;\n    readonly startY: number;\n    readonly endY: number;\n}\n\ninterface D3RectSpec {\n    readonly x: number;\n    readonly y: number;\n    readonly width: number;\n    readonly height: number;\n}\n\ninterface D3LegendSpec {\n    readonly symbolX: number;\n    readonly textX: number;\n    readonly symbolStartY: number;\n    readonly textStartY: number;\n    readonly incrementY: number;\n}\n\ninterface ExtremeValues {\n    readonly minX: number;\n    readonly maxX: number;\n    readonly minY: number;\n    readonly maxY: number;\n}\n\nconst BUFFER_PROPORTION = 1 / 20;\nconst MARGINS_PROPORTION = 1 / 40;\nconst LEGEND_PROPORTION = 1 / 6;\nconst CIRCLE_R = 2;\n\n\ninterface ProjectionChartProps {\n    readonly dimensions: Dimensions;\n    readonly data: Data;\n}\n\nconst createGroups = (rootG: RootSelection) => {\n    rootG.append('g').attr(\"id\", \"circlesG\").attr(\"clip-path\", \"url(#clip)\");\n    rootG.append('g').attr(\"id\", 'legendCirclesG');\n    rootG.append('g').attr(\"id\", \"legendTextG\");\n    rootG.append('g').attr(\"id\", \"xAxisG\");\n    rootG.append('g').attr(\"id\", \"yAxisG\");\n}\n\nconst createScales = ({minX, maxX, minY, maxY}: ExtremeValues, {startX, endX, startY, endY}: D3Coords) => {\n\n\n    const xScaleBuffer = (maxX - minX) * BUFFER_PROPORTION;\n    const yScaleBuffer = (maxY - minY) * BUFFER_PROPORTION;\n\n    const xScale = d3.scaleLinear()\n        .domain([minX - xScaleBuffer, maxX + xScaleBuffer])\n        .range([startX, endX]);\n    const yScale = d3.scaleLinear()\n        .domain([minY - yScaleBuffer, maxY + yScaleBuffer])\n        .range([startY, endY]);\n\n    return {xScale, yScale};\n}\n\nconst removeAppendDefs = (rootG: RootSelection, {x, y, width, height}: D3RectSpec) => {\n    rootG.selectAll(\"defs\").remove().exit();\n\n    // Add a clipPath: everything out of this area won't be drawn.\n    rootG.append(\"defs\").append(\"SVG:clipPath\")\n        .attr(\"id\", \"clip\")\n        .append(\"SVG:rect\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"x\", x)\n        .attr(\"y\", y);\n}\n//\n// const joinLegend = (rootG: RootSelection, labels: string[], {\n//     symbolX,\n//     textX,\n//     symbolStartY,\n//     textStartY,\n//     incrementY\n// }: D3LegendSpec) => {\n//     const legendCirclesG = rootG.select('#legendCirclesG');\n//     const legendTextG = rootG.select('#legendTextG');\n//\n//     legendCirclesG.selectAll('circle')\n//         .data(labels)\n//         .join(\"circle\")\n//         .attr('r', 2 * CIRCLE_R)\n//         .style(\"stroke\", \"black\")\n//         .style(\"stroke-width\", .25)\n//         // @ts-ignore\n//         .style(\"fill\", (label) => {\n//             return COLORS(String(label));\n//         })\n//         .attr('cx', function () {\n//             return symbolX;\n//         })\n//         .attr('cy', function (d: any, i: number) {\n//             return symbolStartY + (i * incrementY);\n//         })\n//\n//     legendTextG.selectAll('text')\n//         .data(labels)\n//         .join(\"text\")\n//         .attr('x', function (d, i) {\n//             return textX;\n//         })\n//         .attr('y', function (d, i) {\n//             return textStartY + (i * incrementY);\n//         })\n//         .text((d) => d);\n// }\n\n\nconst callAxis = (rootG: RootSelection,\n                  {xScale, yScale}: Scales,\n                  {startX, startY}: D3Coords) => {\n    const xAxisG = rootG.select('#xAxisG');\n    const yAxisG = rootG.select('#yAxisG');\n\n    const xAxis = d3.axisBottom(xScale).tickFormat(() => \"\").tickSize(0);\n    const yAxis = d3.axisLeft(yScale).tickFormat(() => \"\").tickSize(0);\n\n    xAxisG\n        .attr(\"class\", \"axis\")\n        .attr(\"transform\", \"translate(0,\" + startY + \")\")\n        // @ts-ignore\n        .call(xAxis);\n\n    yAxisG\n        .attr(\"class\", \"axis\")\n        .attr(\"transform\", \"translate(\" + startX + \", 0)\")\n        // @ts-ignore\n        .call(yAxis);\n}\n\nconst removeAppendZoom = (rootG: RootSelection,\n                          {xScale, yScale}: Scales,\n                          {startX, endX, startY, endY}: D3Coords,\n                          {x, y, width, height}: D3RectSpec) => {\n    const circlesG = rootG.select('#circlesG');\n\n    circlesG.selectAll('#zoom_rect').remove().exit()\n\n\n    const updateChart = (t: any) => {\n        // recover the new scale\n        const newXScale = t.rescaleX(xScale);\n        const newYScale = t.rescaleY(yScale);\n\n        // update circle position\n        circlesG\n            .selectAll(\"circle\")\n            .attr('cx', function (d) {\n                const mol = d as ProjectedDataInstance\n                return newXScale(mol.projection[0])\n            })\n            .attr('cy', function (d) {\n                const mol = d as ProjectedDataInstance\n                return newYScale(mol.projection[1])\n            });\n    }\n\n    const zoom = d3.zoom()\n        .scaleExtent([.8, 40])  // This control how much you can unzoom (x0.5) and zoom (x20)\n        .extent([[startX, startY], [endX, endY]])\n        .duration(0)\n        .on(\"end\", (event) => {\n            // @ts-ignore\n            updateChart(event.transform)\n        });\n\n    circlesG.append(\"rect\")\n        .attr(\"id\", \"zoom_rect\")\n        .raise()\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .style(\"fill\", \"none\")\n        .style(\"pointer-events\", \"all\")\n        .attr('transform', 'translate(' + x + ',' + y + ')')\n        //@ts-ignore\n        .call(zoom);\n}\n\nconst joinCircles = (rootG: RootSelection,\n                     data: ProjectedData,\n                     {xScale, yScale}: Scales) => {\n    const circlesG = rootG.select('#circlesG');\n\n    circlesG\n        .selectAll('circle')\n        .data(data)\n        .join('circle')\n        .raise()\n        .attr('id', (d) => `id${d.uid}`)\n        .attr('cx', function (d) {\n            return xScale(d.projection[0]) as number;\n        })\n        .attr('cy', function (d) {\n            return yScale(d.projection[1]) as number;\n        })\n        .attr('r', CIRCLE_R)\n        .style(\"stroke\", \"black\")\n        .style(\"stroke-width\", .25)\n        // @ts-ignore\n        .style(\"fill\", (d) => {\n            return COLORS(String(d.target));\n        });\n\n    circlesG\n        .select(\".selected\")\n        .style(\"fill\", \"#fff13b\");\n}\n\nconst updateSelectedCircle = (rootG: RootSelection, selectedMolecule: DataInstance) => {\n    const circlesG = rootG\n        .select('#circlesG');\n\n    circlesG\n        .select(\".selected\")\n        .attr('class', null)\n        // @ts-ignore\n        .style('fill', (d) => {\n            // Danger\n            const mol = d as DataInstance;\n            return COLORS(String(mol.target));\n        });\n\n    d3.select(`#id${selectedMolecule.uid}`)\n        .attr('class', 'selected')\n        .order()\n        .raise()\n        .style(\"fill\", \"#fff13b\");\n}\n\n\nconst getCoordsAndSpecs = (dimensions: Dimensions, labelLength: number) => {\n    const {width, height} = dimensions;\n    const margins = {w: width * MARGINS_PROPORTION, h: height * MARGINS_PROPORTION};\n    const legend_space = width * LEGEND_PROPORTION;\n\n    const scatterCoords = {\n        startX: margins.w,\n        endX: (width - margins.w),\n        // endX: (width - margins.w - legend_space),\n        startY: (height - margins.h),\n        endY: margins.h\n    }\n\n    const rectSpec = {\n        x: margins.w,\n        y: margins.h,\n        // width: (width - 2 * margins.w - legend_space),\n        width: (width - 2 * margins.w),\n        height: (height - 2 * margins.h)\n    }\n\n    const legendSpec: D3LegendSpec = {\n        symbolX: width - (margins.w / 2) - legend_space,\n        textX: width - (margins.w / 2) - legend_space + 2 * CIRCLE_R,\n        symbolStartY: margins.h,\n        textStartY: margins.h + (2 * CIRCLE_R),\n        incrementY: ((labelLength / 2) * 8 * CIRCLE_R)\n    }\n\n    return {scatterCoords, rectSpec, legendSpec}\n}\n\nconst getExtrema = (data: ProjectedData) => {\n    const minX = d3.min(data, d => d.projection[0]);\n    const maxX = d3.max(data, d => d.projection[0]);\n    const minY = d3.min(data, d => d.projection[1]);\n    const maxY = d3.max(data, d => d.projection[1]);\n\n    return {minX, maxX, minY, maxY};\n}\n\n\nconst ScatterChart: React.FC<ProjectionChartProps> = (props) => {\n    const d3Container = useRef<SVGSVGElement>(null);\n    const data = props.data;\n    const dimensions = props.dimensions;\n\n\n    useEffect(() => {\n        if (d3Container.current !== null) {\n            const rootG = d3.select(d3Container.current);\n            createGroups(rootG);\n        }\n    }, []);\n\n\n    useEffect(() => {\n        if (data !== undefined && d3Container.current !== null && isProjected(data)) {\n            const extrema = getExtrema(data);\n            const labels = Array.from(new Set(data.map(d => d.target)));\n\n            const {scatterCoords, rectSpec, legendSpec} = getCoordsAndSpecs(dimensions, labels.length);\n            if (Object.values(extrema).every(o => o !== undefined)) {\n                // @ts-ignore\n                const scales: Scales = createScales(extrema, scatterCoords);\n                const rootG = d3.select(d3Container.current);\n                removeAppendDefs(rootG, rectSpec);\n                // joinLegend(rootG, labels, legendSpec);\n                callAxis(rootG, scales, scatterCoords);\n                removeAppendZoom(rootG, scales, scatterCoords, rectSpec);\n                joinCircles(rootG, data, scales)\n            }\n        }\n    }, [data, dimensions]);\n\n    return (\n        <svg ref={d3Container} width={dimensions.width} height={dimensions.height}/>\n    )\n\n}\n\nconst ResponsiveScatterChart = withDimensions(ScatterChart);\n\nconst mapStateToProps = (state: RootState) => ({\n    data: selectAllData(state),\n});\n\nexport default connect(\n    mapStateToProps,\n)(ResponsiveScatterChart);\n","/home/gabriel/Documents/ipca/frontend/app/src/api/dataClient.ts",[],"/home/gabriel/Documents/ipca/frontend/app/src/api/common.ts",[],"/home/gabriel/Documents/ipca/frontend/app/src/api/modelClient.ts",[],"/home/gabriel/Documents/ipca/frontend/app/src/components/DatasetPicker.tsx",[],{"ruleId":"81","replacedBy":"82"},{"ruleId":"83","replacedBy":"84"},{"ruleId":"85","severity":1,"message":"86","line":6,"column":46,"nodeType":"87","messageId":"88","endLine":6,"endColumn":57},{"ruleId":"85","severity":1,"message":"89","line":2,"column":9,"nodeType":"87","messageId":"88","endLine":2,"endColumn":20},{"ruleId":"85","severity":1,"message":"90","line":2,"column":33,"nodeType":"87","messageId":"88","endLine":2,"endColumn":49},{"ruleId":"85","severity":1,"message":"86","line":3,"column":9,"nodeType":"87","messageId":"88","endLine":3,"endColumn":20},{"ruleId":"85","severity":1,"message":"91","line":3,"column":43,"nodeType":"87","messageId":"88","endLine":3,"endColumn":60},{"ruleId":"85","severity":1,"message":"92","line":3,"column":62,"nodeType":"87","messageId":"88","endLine":3,"endColumn":75},{"ruleId":"85","severity":1,"message":"90","line":6,"column":20,"nodeType":"87","messageId":"88","endLine":6,"endColumn":36},{"ruleId":"85","severity":1,"message":"93","line":7,"column":24,"nodeType":"87","messageId":"88","endLine":7,"endColumn":43},{"ruleId":"85","severity":1,"message":"94","line":241,"column":7,"nodeType":"87","messageId":"88","endLine":241,"endColumn":27},{"ruleId":"85","severity":1,"message":"95","line":324,"column":45,"nodeType":"87","messageId":"88","endLine":324,"endColumn":55},"no-native-reassign",["96"],"no-negated-in-lhs",["97"],"@typescript-eslint/no-unused-vars","'projectData' is defined but never used.","Identifier","unusedVar","'AppDispatch' is defined but never used.","'useTypedSelector' is defined but never used.","'selectDataScaling' is defined but never used.","'updateScaling' is defined but never used.","'selectAllScaledData' is defined but never used.","'updateSelectedCircle' is assigned a value but never used.","'legendSpec' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]